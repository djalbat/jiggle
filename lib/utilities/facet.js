"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.cloneEdges = cloneEdges;
exports.cloneNormal = cloneNormal;
exports.cloneVertices = cloneVertices;
exports.calculateEdges = calculateEdges;
exports.calculateNormal = calculateNormal;
exports.calculateArea = calculateArea;
var _constants = require("../constants");
var _array = require("../utilities/array");
var _vector = require("../maths/vector");
function cloneEdges(edges) {
    edges = edges.map(function(edge) {
        return edge.clone();
    });
    return edges;
}
function cloneNormal(normal) {
    normal = normal.clone();
    return normal;
}
function cloneVertices(vertices) {
    vertices = vertices.map(function(vertex) {
        return vertex.clone();
    });
    return vertices;
}
function calculateEdges(vertices, Edge) {
    var edges = vertices.map(function(vertex, index) {
        var startIndex = index, endIndex = (startIndex + 1) % _constants.VERTICES_LENGTH, startVertex = vertices[startIndex], endVertex = vertices[endIndex], edge = Edge.fromStartVertexAndEndVertex(startVertex, endVertex);
        return edge;
    });
    return edges;
}
function calculateNormal(vertices, Normal) {
    var normal = Normal.fromVertices(vertices);
    return normal;
}
function calculateArea(vertices) {
    var firstVertex = _array.first(vertices), secondVertex = _array.second(vertices), thirdVertex = _array.third(vertices), firstVertexPosition = firstVertex.getPosition(), secondVertexPosition = secondVertex.getPosition(), thirdVertexPosition = thirdVertex.getPosition(), firstExtent = _vector.subtract3(secondVertexPosition, firstVertexPosition), secondExtent = _vector.subtract3(thirdVertexPosition, firstVertexPosition), area = _vector.length3(_vector.cross3(firstExtent, secondExtent)) / 2;
    return area;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsaXRpZXMvZmFjZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFZFUlRJQ0VTX0xFTkdUSCB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGZpcnN0LCBzZWNvbmQsIHRoaXJkIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9hcnJheVwiO1xuaW1wb3J0IHsgc3VidHJhY3QzLCBjcm9zczMsIGxlbmd0aDMgfSBmcm9tIFwiLi4vbWF0aHMvdmVjdG9yXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUVkZ2VzKGVkZ2VzKSB7XG4gIGVkZ2VzID0gZWRnZXMubWFwKChlZGdlKSA9PiBlZGdlLmNsb25lKCkpO1xuXG4gIHJldHVybiBlZGdlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lTm9ybWFsKG5vcm1hbCkge1xuICBub3JtYWwgPSBub3JtYWwuY2xvbmUoKTtcbiAgXG4gIHJldHVybiBub3JtYWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVZlcnRpY2VzKHZlcnRpY2VzKSB7XG4gIHZlcnRpY2VzID0gdmVydGljZXMubWFwKCh2ZXJ0ZXgpID0+IHZlcnRleC5jbG9uZSgpKTtcblxuICByZXR1cm4gdmVydGljZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVFZGdlcyh2ZXJ0aWNlcywgRWRnZSkge1xuICBjb25zdCBlZGdlcyA9IHZlcnRpY2VzLm1hcCgodmVydGV4LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleCwgLy8vXG4gICAgICAgICAgZW5kSW5kZXggPSAoc3RhcnRJbmRleCArIDEpICUgVkVSVElDRVNfTEVOR1RILFxuICAgICAgICAgIHN0YXJ0VmVydGV4ID0gdmVydGljZXNbc3RhcnRJbmRleF0sXG4gICAgICAgICAgZW5kVmVydGV4ID0gdmVydGljZXNbZW5kSW5kZXhdLFxuICAgICAgICAgIGVkZ2UgPSBFZGdlLmZyb21TdGFydFZlcnRleEFuZEVuZFZlcnRleChzdGFydFZlcnRleCwgZW5kVmVydGV4KTtcblxuICAgIHJldHVybiBlZGdlO1xuICB9KTtcblxuICByZXR1cm4gZWRnZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVOb3JtYWwodmVydGljZXMsIE5vcm1hbCkge1xuICBjb25zdCBub3JtYWwgPSBOb3JtYWwuZnJvbVZlcnRpY2VzKHZlcnRpY2VzKTtcblxuICByZXR1cm4gbm9ybWFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQXJlYSh2ZXJ0aWNlcykge1xuICBjb25zdCBmaXJzdFZlcnRleCA9IGZpcnN0KHZlcnRpY2VzKSxcbiAgICAgICAgc2Vjb25kVmVydGV4ID0gc2Vjb25kKHZlcnRpY2VzKSxcbiAgICAgICAgdGhpcmRWZXJ0ZXggPSB0aGlyZCh2ZXJ0aWNlcyksXG4gICAgICAgIGZpcnN0VmVydGV4UG9zaXRpb24gPSBmaXJzdFZlcnRleC5nZXRQb3NpdGlvbigpLFxuICAgICAgICBzZWNvbmRWZXJ0ZXhQb3NpdGlvbiA9IHNlY29uZFZlcnRleC5nZXRQb3NpdGlvbigpLFxuICAgICAgICB0aGlyZFZlcnRleFBvc2l0aW9uID0gdGhpcmRWZXJ0ZXguZ2V0UG9zaXRpb24oKSxcbiAgICAgICAgZmlyc3RFeHRlbnQgPSBzdWJ0cmFjdDMoc2Vjb25kVmVydGV4UG9zaXRpb24sIGZpcnN0VmVydGV4UG9zaXRpb24pLFxuICAgICAgICBzZWNvbmRFeHRlbnQgPSBzdWJ0cmFjdDModGhpcmRWZXJ0ZXhQb3NpdGlvbiwgZmlyc3RWZXJ0ZXhQb3NpdGlvbiksXG4gICAgICAgIGFyZWEgPSBsZW5ndGgzKGNyb3NzMyhmaXJzdEV4dGVudCwgc2Vjb25kRXh0ZW50KSkgLyAyO1xuXG4gIHJldHVybiBhcmVhO1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJDQUFBLFVBQVk7Ozs7UUFNSSxVQUFVLEdBQVYsVUFBVTtRQU1WLFdBQVcsR0FBWCxXQUFXO1FBTVgsYUFBYSxHQUFiLGFBQWE7UUFNYixjQUFjLEdBQWQsY0FBYztRQWNkLGVBQWUsR0FBZixlQUFlO1FBTWYsYUFBYSxHQUFiLGFBQWE7SUExQ0csVUFBYztJQUNULE1BQW9CO0lBQ2QsT0FBaUI7U0FFNUMsVUFBVSxDQUFDLEtBQUs7SUFDOUIsS0FBSyxHQUFHLEtBQUssQ0FBQyxHQUFHLFVBQUUsSUFBSTtlQUFLLElBQUksQ0FBQyxLQUFLOztXQUUvQixLQUFLOztTQUdFLFdBQVcsQ0FBQyxNQUFNO0lBQ2hDLE1BQU0sR0FBRyxNQUFNLENBQUMsS0FBSztXQUVkLE1BQU07O1NBR0MsYUFBYSxDQUFDLFFBQVE7SUFDcEMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxHQUFHLFVBQUUsTUFBTTtlQUFLLE1BQU0sQ0FBQyxLQUFLOztXQUV6QyxRQUFROztTQUdELGNBQWMsQ0FBQyxRQUFRLEVBQUUsSUFBSTtRQUNyQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEdBQUcsVUFBRSxNQUFNLEVBQUUsS0FBSztZQUNqQyxVQUFVLEdBQUcsS0FBSyxFQUNsQixRQUFRLElBQUksVUFBVSxHQUFHLENBQUMsSUF6QkosVUFBYyxrQkEwQnBDLFdBQVcsR0FBRyxRQUFRLENBQUMsVUFBVSxHQUNqQyxTQUFTLEdBQUcsUUFBUSxDQUFDLFFBQVEsR0FDN0IsSUFBSSxHQUFHLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxXQUFXLEVBQUUsU0FBUztlQUU3RCxJQUFJOztXQUdOLEtBQUs7O1NBR0UsZUFBZSxDQUFDLFFBQVEsRUFBRSxNQUFNO1FBQ3hDLE1BQU0sR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLFFBQVE7V0FFcEMsTUFBTTs7U0FHQyxhQUFhLENBQUMsUUFBUTtRQUM5QixXQUFXLEdBMUNrQixNQUFvQixPQTBDN0IsUUFBUSxHQUM1QixZQUFZLEdBM0NpQixNQUFvQixRQTJDM0IsUUFBUSxHQUM5QixXQUFXLEdBNUNrQixNQUFvQixPQTRDN0IsUUFBUSxHQUM1QixtQkFBbUIsR0FBRyxXQUFXLENBQUMsV0FBVyxJQUM3QyxvQkFBb0IsR0FBRyxZQUFZLENBQUMsV0FBVyxJQUMvQyxtQkFBbUIsR0FBRyxXQUFXLENBQUMsV0FBVyxJQUM3QyxXQUFXLEdBL0N3QixPQUFpQixXQStDNUIsb0JBQW9CLEVBQUUsbUJBQW1CLEdBQ2pFLFlBQVksR0FoRHVCLE9BQWlCLFdBZ0QzQixtQkFBbUIsRUFBRSxtQkFBbUIsR0FDakUsSUFBSSxHQWpEK0IsT0FBaUIsU0FBakIsT0FBaUIsUUFpRDlCLFdBQVcsRUFBRSxZQUFZLEtBQUssQ0FBQztXQUVwRCxJQUFJIn0=